#!/bin/sh
#
# greins This is the init script that tacks up the gunicorn
#
# chkconfig: 2345 72 28
# description: Starts and stops the gunicorn daemon that handles \
#	       routing to a bunch of hosted WSGI apps using greins.

### BEGIN INIT INFO
# Provides: greins
# Required-Start: $local_fs $network
# Required-Stop: $local_fs $network
# Should-Start: $remote_fs
# Should-Stop: $remote_fs
# Default-Start: 2 3 4 5
# Default-Stop: 0 1 6
# Short-Description: start and stop greins gunicorn tack
# Description: Greins is routing middleware for gunicorn
### END INIT INFO

# Source function library.
. /etc/rc.d/init.d/functions
. /lib/lsb/init-functions

prog=gunicorn
exec=/usr/bin/$prog

# default values
GREINS_BIND_ADDR=unix:/var/run/greins/greins.sock
GREINS_LOG_FILE=/var/log/greins/greins.log
GREINS_CONF_D=/etc/greins/conf.d
GREINS_USER=nobody
GREINS_GROUP=nobody
GREINS_OPTIONS=

# if this script was run from a symlink, follow links until we discover a
# corresponding configuration file or get to the end of the link chain
fullname=$0
basename=$(basename $fullname)
while [ ! -e /etc/sysconfig/$basename -a -L $fullname ]
do
    link=$(readlink $fullname)
    if [ $(expr $link : "\.") -gt 0 ]
    then
        fullname="$(dirname $fullname)/$link"
    else
        fullname="$link"
    fi
    basename=$(basename $fullname)
done

[ -e /etc/sysconfig/$basename ] && . /etc/sysconfig/$basename

pidfile=/var/run/greins/$basename.pid
lockfile=/var/lock/subsys/$basename

# export variables needed inside gunicorn
export GREINS_CONF_D

start() {
    [ -x $exec ] || exit 5
    echo -n $"Starting $basename: "
    rh_status_q && log_warning_msg $"already running" && exit 0
    $exec -D \
      -p $pidfile \
      --log-file $GREINS_LOG_FILE \
      -u $GREINS_USER -g $GREINS_GROUP \
      -k egg:gunicorn#gevent \
      -b $GREINS_BIND_ADDR \
      $GREINS_OPTIONS greins.router:router >/dev/null
    retval=$?
    [ $retval -eq 0 ] && touch $lockfile && \
        log_success_msg $"done" || \
        log_failure_msg $"failed"
    return $retval
}

stop() {
    echo -n $"Stopping $basename: "
    retval=0
    if ! rh_status_q ; then
        log_warning_msg $"already stopped" && exit 0
    else
        killproc -p $pidfile $prog -QUIT
        retval=$?
    fi
    if [ $retval -eq 0 ]; then
        STOPTIMEOUT=60
        while [ $STOPTIMEOUT -gt 1 ]; do
            rh_status_q || break
            sleep 1
            let STOPTIMEOUT=${STOPTIMEOUT}-1
        done
        if [ $STOPTIMEOUT -eq 0 ]; then
            killproc -p $pidfile $prog
            retval=$?
            log_warning_msg $"timeout error occurred trying to stop gracefully. Killing."
            if [ $retval -eq 0 ]; then
                rm -f $lockfile $pidfile
                log_success_msg $"killed"
            else
                log_failure_msg $"failed"
            fi
        else
            log_success_msg $"stopped"
            rm -f $lockfile $pidfile
        fi
    fi
    return $retval
}

restart() {
    [ -x $exec ] || exit 5
    status -p $pidfile.oldbin $prog >/dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo -n $"Killing off old, defunct master: "
        killproc -p $pidfile.oldbin $prog
        log_success_msg $"killed"
    fi
    rm -f $pidfile.oldbin

    echo -n "Gracefully restarting $basename: "
    rh_status_q
    if [ $? -ne 0 ]; then
        log_warning_msg $"$basename not running"
        start
        return $?
    else
        log_success_msg $"found a running instance"
    fi

    echo -n $"Starting new master: "
    killproc -p $pidfile $prog -USR2
    TIMEOUT=60
    while [ $TIMEOUT -gt 1 ]; do
        status -p $pidfile.oldbin $prog >/dev/null 2>&1 && rh_status_q && break
        sleep 1
        let TIMEOUT=${TIMEOUT}-1
    done
    if [ $TIMEOUT -eq 0 ]; then
        log_failure_msg $"failed"
        return 1
    else
        log_success_msg $"started"
    fi

    echo -n $"Shutting down old workers: "
    killproc -p $pidfile.oldbin $prog -WINCH
    TIMEOUT=60
    while [ $TIMEOUT -gt 1 ]; do
        ps axo ppid | grep -q -f $pidfile.oldbin - && break
        sleep 1
        let TIMEOUT=${TIMEOUT}-1
    done
    if [ $TIMEOUT -eq 0 ]; then
        log_warning_msg $"failed"
    else
        log_success_msg $"killed"
    fi
    return 1
}

reload() {
    killproc -p $pidfile $prog -HUP
}

rollback() {
    [ -x $exec ] || exit 5
    echo -n "Rolling back to old master: "
    status -p $pidfile.oldbin $prog >/dev/null 2>&1
    if [ $? -ne 0 ]; then
        log_failure_msg $"none found"
        exit 1
    fi

    if [ -f $pidfile ]; then
        mv $pidfile $pidfile.tmp
    fi

    killproc -p $pidfile.oldbin $prog -HUP
    killproc -p $pidfile.tmp $prog
    log_success_msg $"done"
}

rh_status() {
    # run checks to determine if the service is running or use generic status
    status -p $pidfile $prog
}

rh_status_q() {
    rh_status >/dev/null 2>&1
}


case "$1" in
    start)
        $1
        ;;
    stop)
        $1
        ;;
    restart|force-reload)
        $1
        ;;
    reload)
        rh_status_q || exit 7
        $1
        ;;
    rollback)
        $1
        ;;
    status)
        rh_status
        ;;
    condrestart|try-restart)
        rh_status_q || exit 0
        restart
        ;;
    *)
        log_failure_msg $"Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload}"
        exit 2
esac
exit $?
